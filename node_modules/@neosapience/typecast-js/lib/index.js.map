{"version":3,"sources":["../src/errors.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { ApiErrorResponse } from './types';\n\nexport class TypecastAPIError extends Error {\n  public readonly statusCode: number;\n  public readonly response?: ApiErrorResponse;\n\n  constructor(message: string, statusCode: number, response?: ApiErrorResponse) {\n    super(message);\n    this.name = 'TypecastAPIError';\n    this.statusCode = statusCode;\n    this.response = response;\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TypecastAPIError);\n    }\n  }\n\n  static fromResponse(statusCode: number, statusText: string, data?: ApiErrorResponse): TypecastAPIError {\n    let message: string;\n\n    switch (statusCode) {\n      case 400:\n        message = 'Bad Request - The request was invalid or cannot be served';\n        break;\n      case 401:\n        message = 'Unauthorized - Invalid or missing API key';\n        break;\n      case 402:\n        message = 'Payment Required - Insufficient credits to complete the request';\n        break;\n      case 404:\n        message = 'Not Found - The requested resource does not exist';\n        break;\n      case 422:\n        message = 'Validation Error - The request data failed validation';\n        break;\n      case 500:\n        message = 'Internal Server Error - Something went wrong on the server';\n        break;\n      default:\n        message = `API request failed with status ${statusCode}: ${statusText}`;\n    }\n\n    if (data?.detail) {\n      const detailStr = typeof data.detail === 'string' \n        ? data.detail \n        : JSON.stringify(data.detail);\n      message += ` - ${detailStr}`;\n    }\n\n    return new TypecastAPIError(message, statusCode, data);\n  }\n}\n\n","import axios, { AxiosInstance, AxiosError } from 'axios';\nimport { ClientConfig, TTSRequest, TTSResponse, ApiErrorResponse } from './types';\nimport { VoicesResponse } from './types/Voices';\nimport { TypecastAPIError } from './errors';\n\nexport class TypecastClient {\n  private client: AxiosInstance;\n  private config: ClientConfig;\n\n  constructor(config: Partial<ClientConfig> = {}) {\n    this.config = {\n      baseHost: process.env.TYPECAST_API_HOST || 'https://api.typecast.ai',\n      apiKey: process.env.TYPECAST_API_KEY || '',\n      ...config,\n    };\n    this.client = axios.create({\n      baseURL: this.config.baseHost,\n      headers: {\n        'X-API-KEY': this.config.apiKey,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    // Add response interceptor for error handling\n    this.client.interceptors.response.use(\n      (response) => response,\n      (error: AxiosError<ApiErrorResponse>) => {\n        if (error.response) {\n          throw TypecastAPIError.fromResponse(\n            error.response.status,\n            error.response.statusText,\n            error.response.data\n          );\n        }\n        throw error;\n      }\n    );\n  }\n\n  async textToSpeech(request: TTSRequest): Promise<TTSResponse> {\n    const response = await this.client.post<ArrayBuffer>('/v1/text-to-speech', request, {\n      responseType: 'arraybuffer',\n    });\n\n    const contentType = String(response.headers['content-type'] || 'audio/wav');\n    const formatFromHeader = contentType.split('/')[1] || 'wav';\n    const format: 'wav' | 'mp3' = formatFromHeader === 'mp3' ? 'mp3' : 'wav';\n\n    const durationHeader: unknown = response.headers['x-audio-duration'];\n    const duration = typeof durationHeader === 'string' ? Number(durationHeader) : 0;\n\n    return {\n      audioData: response.data,\n      duration,\n      format,\n    };\n  }\n\n  async getVoices(model?: string): Promise<VoicesResponse[]> {\n    const response = await this.client.get<VoicesResponse[]>('/v1/voices', {\n      params: model ? { model } : undefined,\n    });\n    return response.data;\n  }\n\n  async getVoiceById(voiceId: string, model?: string): Promise<VoicesResponse[]> {\n    const response = await this.client.get<VoicesResponse[]>(`/v1/voices/${voiceId}`, {\n      params: model ? { model } : undefined,\n    });\n    return response.data;\n  }\n}\n"]}