'use strict';

var axios = require('axios');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var axios__default = /*#__PURE__*/_interopDefault(axios);

// src/client.ts

// src/errors.ts
var TypecastAPIError = class _TypecastAPIError extends Error {
  constructor(message, statusCode, response) {
    super(message);
    this.name = "TypecastAPIError";
    this.statusCode = statusCode;
    this.response = response;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _TypecastAPIError);
    }
  }
  static fromResponse(statusCode, statusText, data) {
    let message;
    switch (statusCode) {
      case 400:
        message = "Bad Request - The request was invalid or cannot be served";
        break;
      case 401:
        message = "Unauthorized - Invalid or missing API key";
        break;
      case 402:
        message = "Payment Required - Insufficient credits to complete the request";
        break;
      case 404:
        message = "Not Found - The requested resource does not exist";
        break;
      case 422:
        message = "Validation Error - The request data failed validation";
        break;
      case 500:
        message = "Internal Server Error - Something went wrong on the server";
        break;
      default:
        message = `API request failed with status ${statusCode}: ${statusText}`;
    }
    if (data?.detail) {
      const detailStr = typeof data.detail === "string" ? data.detail : JSON.stringify(data.detail);
      message += ` - ${detailStr}`;
    }
    return new _TypecastAPIError(message, statusCode, data);
  }
};

// src/client.ts
var TypecastClient = class {
  constructor(config = {}) {
    this.config = {
      baseHost: process.env.TYPECAST_API_HOST || "https://api.typecast.ai",
      apiKey: process.env.TYPECAST_API_KEY || "",
      ...config
    };
    this.client = axios__default.default.create({
      baseURL: this.config.baseHost,
      headers: {
        "X-API-KEY": this.config.apiKey,
        "Content-Type": "application/json"
      }
    });
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response) {
          throw TypecastAPIError.fromResponse(
            error.response.status,
            error.response.statusText,
            error.response.data
          );
        }
        throw error;
      }
    );
  }
  async textToSpeech(request) {
    const response = await this.client.post("/v1/text-to-speech", request, {
      responseType: "arraybuffer"
    });
    const contentType = String(response.headers["content-type"] || "audio/wav");
    const formatFromHeader = contentType.split("/")[1] || "wav";
    const format = formatFromHeader === "mp3" ? "mp3" : "wav";
    const durationHeader = response.headers["x-audio-duration"];
    const duration = typeof durationHeader === "string" ? Number(durationHeader) : 0;
    return {
      audioData: response.data,
      duration,
      format
    };
  }
  async getVoices(model) {
    const response = await this.client.get("/v1/voices", {
      params: model ? { model } : void 0
    });
    return response.data;
  }
  async getVoiceById(voiceId, model) {
    const response = await this.client.get(`/v1/voices/${voiceId}`, {
      params: model ? { model } : void 0
    });
    return response.data;
  }
};

exports.TypecastAPIError = TypecastAPIError;
exports.TypecastClient = TypecastClient;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map